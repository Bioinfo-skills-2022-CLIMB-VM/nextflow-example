#!/usr/bin/env nextflow
 
nextflow.enable.dsl=2

params.input = "data/*.fastq.gz"


process NUM_LINES {

    input:
    path(read)

    /*
     For this example we will redirect the output to the terminal, while usually
     we will pass output files (to the next process)
    */
    output:
    path("*.numlines")

    script:
    /*  Triple quote syntax """, 
        Triple-single-quoted strings may span multiple lines. 
        The content of the string can cross line boundaries without the need to split the string in several pieces and without concatenation or newline escape characters. 
    */
    """
    
    printf '${read},' > ${read}.numlines
    gunzip -c ${read} | wc -l >> ${read}.numlines
    """
}

process MAX_LINES {
    input:
    path("*.numlines")

    output:
    stdout

    script:
    """
    echo -n "Max lines (file): "
    cat *.numlines | sort -n -k 2,2 -t, | tail -n 1 | cut -f 1 -d,
    """
}
//  The default workflow
workflow {

    //  Input data is received through channels
    input_ch = Channel.fromPath(params.input)

    /*  The script to execute is called by its process name,
        and input is provided between brackets. */
    NUM_LINES(input_ch)

    /*  Here we have a second process that takes as input 
        all the output files generated by the first process,
        gathered via "collect"
    */
    MAX_LINES( NUM_LINES.out.collect() ).view()
}

